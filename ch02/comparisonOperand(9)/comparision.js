/**
 * '비교 연산자
 * 보다 큼, 작음 : a>b, a<b
 * 보다 크거나, 작거나 같음 : a>=b,a<=b
 * 같음(동등) a==b. 등호(=)가 두개 연달아 온다.
 * 같지 않음(부등) a!=b
 * 
 * 불린형 반환
 * 다른 연산자와 마찬가지로 비교 연산자 역시 값을 반환한다.
 * true : 긍정, 참, 사실
 * false : 부정, 거짓, 사실이 아님
 */

alert(2>1); // true
alert(2==1); // false
alert(2!=1); // true
//반환된 불린값은 다른 여타 값처럼 변수에 할당 할 수 있다.
let result=5>4; //비교 결과를 변수에 할당
alert(result); // true

/**
 * 문자열 비교
 * JS는 사전순으로 문자열을 비교한다.
 * 이 기준을 적용하면 사전 뒤쪽의 문자열은 사전 앞쪽의 문자열보다 크다고 판단한다.
 */
alert('Z'>'A'); // true
alert('Glow'>'Glee'); // true
alert('Bee'>'Be'); //true

/**
 * 문자열 비교시 적용되는 알고리즘은 다음과 같다
 * 1. 두 문자열의 첫 글자를 비교한다.
 * 2. 첫 번째 문자열의 첫 글자가 다른 문자열의 첫 글자보다 크면(작으면), 첫 번째 문자열이 두번째 문자열보다 크다고(작다고)
 * 결론내고 비교를 종료합니다.
 * 3. 두 문자열의 첫 글자가 같으면 두 번째 글자를 같은 방식으로 비교한다.
 * 4. 글자 간 비교가 끝날 떄 까지 이 과정을 반복한다.
 * 5. 비교가 종료되었고, 문자열의 길이도 같다면 두 문자열은 동일하다고 결론낸다.
 * 비교가 종료되었지만 두 문자열의 길이가 다르면 길이가 긴 문자열이 더 크다고 결론 낸다.
 * 
 * 정확히는 사전 순이 아니라 유니코드 순입니다.
자바스크립트의 문자열 비교 알고리즘은 사전이나 전화번호부에서 사용되는 정렬 알고리즘과 아주 유사하지만, 완전히 같진 않습니다.
차이점 중 하나는 자바스크립트는 대·소문자를 따진다는 것입니다. 대문자 'A'와 소문자 'a'를 비교했을 때 소문자 'a'가 더 큽니다. 자바스크립트 내부에서 사용되는 인코딩 표인 유니코드에선 소문자가 대문자보다 더 큰 인덱스를 갖기 때문이죠. 이와 관련한 자세한 내용은 문자열 챕터에서 다루도록 하겠습니다.
 */

/**
 * 다른 형을 가진 값 간의 비교
 * 비교하려는 값의 자료형이 다르면 자바스크립트는 이 값들을 숫자형으로 바꿉니다.
 */
alert('2'>1); //true, 문자열 '2'가 숫자 2로 변환된 후 비교가 진행
alert('01'==1); //ture, 문자열 '01'숫자가 1로 변환된 후 비교가 진행된다.
//불린값의 경우 true -> 1, falese -> 0
alert(true==1); //true
alert(false==0); //true

/**
 * 흥미로운 상황
 * 동시에 일어나지 않을 법한 두 상황이 동시에 일어나는 경우도 있다.
 * 동등비교(==)시 true를 반환함
 * 논리 평가 시 값 하나는 true, 다른 값 하나는 false를 반환함
 * 두 값(a와 b)을 비교하면 참이 반환되는데, 값을 논리 평가한 후 비교하면 하나는 참, 하나는 거짓이 반환된다는 점에 고개를 갸우뚱할 수도 있습니다. 그런데 자바스크립트 관점에선 이런 결과가 아주 자연스럽습니다. 동등 비교 연산자 ==는 (예시에서 문자열 "0"을 숫자 0으로 변환시킨 것처럼) 피연산자를 숫자형으로 바꾸지만, 'Boolean’을 사용한 명시적 변환에는 다른 규칙이 사용되기 때문입니다.
 * 
 */
let a=0;
alert(Boolean(a)); // false

let b="0";
alert(Boolean(b)); // true

alert(a==b); //true

/**
 * 일치 연산자
 * 동등 연산자 ==은 0과 false를 구별하지 못한다.
 */
alert(0==false); //true
//피연산자가 빈 문자열일 때도 같은 문제가 발생
alert(''==false);l //true
/**
 * 이런 문제는 동등 연산자 ==가 형이 다른 피연산자를 비교할 때 피연산자를
 * 숫자형으로 바꾸기 때문에 발생.
 * 빈자열과 false는 숫자형으로 변환하면 0이 된다.
 * 일치 연산자(strict equaility operator) === 를 사용하면 형 변한 없이 값을 비교할 수 있다.
 * 일치 연산자는 지료형의 동등 여부까지 검사하기 때문에 a와 b의 형이 다를 경우
 * a===b는 즉시 false를 반환한다.
 */

alert(0===false); // false, 피연산자의 형이 다르기 떄문이다.
//일치 연산자 ===가 동등 연산자 ==의 엄격한 버전, 불일치 연산자 !==는 !=의 엄격한 버전
//한글자 길지만, 비교 결과가 명확하기 때문에 에러가 발생할 확률을 줄여준다.

/**
 * null이나 undefinec와 비교하기
 * null이나 undefined를 다른 값과 비교할 떈 예상치 않은 일들이 발생한다.
 * 일치 연산자 ===를 사용하여 null과 undefined를 비교
 */
alert(null===undefined); //false

/**
 * 동등 연산자 ==를 사용하여 null과 undefined를 비교
 * 동등 연산자를 통해 null과 undefined를 비교하면 특별한 규칙이 적용돼 true가 반환.
 * 동등 연산자는 null과 undefined를 각별한 커플처럼 취급.
 */
alert(null==undefined); // true

/**
 * 산술 연산자나 기타 비교 연산자 <, >, <=, >=를 사용하여 null과 undefined를 비교
 * null과 undefined는 숫자형으로 변환된다. null은 0, undefined는 NaN으로 변환.
 * 세 가지 규칙들이 어떤 흥미로운 에지 케이스(Edge case)를 만들어내는지 알아보자.
 * 어떻게 하면 에지 케이스가 만들어내는 함정에 빠지지 않을지 알아보자.
 */

//null vs 0
alert(null>0); //(1) false
alert(null==0); //(2) false
alert(null>=0); //(3) true

/**
 * 동등 연산자 ==와 기타 비교 연산자 <, >, <=, >=의 동작 방식이 다르기 때문이다.
 * (1)이 거짓을 (3)에서 참을 반환하는 이유는 null이 숫자형으로 변환돼 0이 되기 때문이다.
 * 
 * 그런데 동등 연산자 ==는 피연산자가 undefined나 Null일 때 형 변환을 하지 않는다. undefined와 null을 비교하
 * 는 경우에만 true를 반환, 그 이외의 경우(null이나 undefined를 다른 값과 비교할 때)는 무조건 false를 반환.
 * 이런 이유 때문에 (2)는 거짓을 반환
 */

//비교가 불가능한 undefined
//undefined를 다른 값과 비교해서는 안된다.
alert(undefined>0); // false(1)
alert(undefined<0); // false(2)
alert(undefined ==0); // false(3)

/**
 * 위 예시를 보면 undefined는 0을 매우 싫어하는 것처럼 보인다. 항상 false를 반환.
 * (1)과 (2)에선 undefined가 NaN으로 변환(숫자형으로의 변환), NaN이 피연사자인 경우 비교 연산자는 항상
 * false를 반환합니다.
 * undefined는 Null 이나 undefined와 같고, 그 이외의 값과는 같지 않기 때문에 (3)은 false를 반환한다.
 */

/**
 * 함정 피하기
 * 일치 연산자 ===를 제외, 비교 연산자의 피연산에 undefined나 null이 오지 않도록 특별히 주의
 * 또한, undefined나 null이 될 가능성이 있는 변수가 <, >, <=, >=의 피연산자가 되지 않도록 주의
 * 만약, 변수가 undefined나 null이 될 가능성이 있다고 판단, 이를 따로 처리하는 코드를 추가
 */

/**
 * summary
 * 비교 연산자는 불린값을 반환
 * 문자열은 문자 단위로 비교, 이 때 비교 기준은  '사전'순이다.
 * 서로 다른 타입의 값을 비교할 떈 숫자형으로 형 변환이 이뤄지고 난 후 비교가 진행된다.(일치 연산자 제와)
 * null과 undefined는 동등 비교(==)시 서로 같지만 다른 값과는 같지 않다.
 * null이나 undefined가 될 확률이 있는 변수가 > 또는 <의 피연산자로 올 때는 주의
 * null, undefiend 여부를 확인하는 코드를 따로 추가하는 습관 들이길 권유
 */

